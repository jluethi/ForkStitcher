%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{MAPS XML Parser}
\date{Jun 20, 2019}
\release{0.1.0}
\author{Joel Luethi}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\index{sites\_of\_interest\_parser (module)@\spxentry{sites\_of\_interest\_parser}\spxextra{module}}\index{MapsXmlParser (class in sites\_of\_interest\_parser)@\spxentry{MapsXmlParser}\spxextra{class in sites\_of\_interest\_parser}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{sites\_of\_interest\_parser.}}\sphinxbfcode{\sphinxupquote{MapsXmlParser}}}{\emph{project\_folder: str}, \emph{name\_of\_highmag\_layer: str = 'highmag'}, \emph{use\_unregistered\_pos: bool = True}, \emph{stitch\_radius: int = 1}}{}
XML Parser class that processes MAPS XMLs and reveals the image tiles belonging to each annotation

This class takes XML files from the Thermo MAPS Application, extracts the location of all its annotations and
compares it to the location of all the image tiles. This gets a bit more complicated, because tiles only have a
relative position in pixels within their layers and those layers are (potentially) turned at arbitrary angles
relative to the global coordinate system (which is in meters).
It is important that the functions are run in the correct order to extract \& process this information. Therefore,
use it by initializing the class and the calling parser.parse\_xml().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{project\_folder}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} The path to the project folder of the MAPS project, containing the XML file, as a string

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{name\_of\_highmag\_layer}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the image layer in MAPS for which tiles containing annotations should
be found. Defaults to ‘highmag’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{use\_unregistered\_pos}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether to use the unregistered position of the tiles (where MAPS thinks it
acquired them =\textgreater{} True, default) or a calculated position (e.g. through stitching in MAPS) should be used for
the tiles (False)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stitch\_radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of images in each direction from the tile containing the annotation should be
stitched. Parser doesn’t do the stitching, just extracts relevant information about neighboring tiles.
Defaults to 1 =\textgreater{} 3x3 images would be stitched.

\end{itemize}

\end{description}\end{quote}
\index{project\_folder\_path (sites\_of\_interest\_parser.MapsXmlParser attribute)@\spxentry{project\_folder\_path}\spxextra{sites\_of\_interest\_parser.MapsXmlParser attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.project_folder_path}}\pysigline{\sphinxbfcode{\sphinxupquote{project\_folder\_path}}}
The path to the project folder of the MAPS project, containing the XML file, as a
string
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{layers (sites\_of\_interest\_parser.MapsXmlParser attribute)@\spxentry{layers}\spxextra{sites\_of\_interest\_parser.MapsXmlParser attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.layers}}\pysigline{\sphinxbfcode{\sphinxupquote{layers}}}
Contains information about the layers (squares/acquisitions). The keys are local paths to
the metadata about the layer and the values are dictionaries again. Each layer contains the information
about the stage position of the center of the layer (in meters, StagePosition\_center\_x \&
StagePosition\_center\_y), about the rotation of the layer relative to the global stage positions (in degrees,
rotation), the number of columns of tiles (images) in the layer (columns), the vertical \& horizontal overlap
between the tiles (overlapVertical, overlapHorizontal), the number of rows of tiles (images) in the layer
(rows), the horizontal field width of each tile (its width in meters, tileHfw), the horizontal field width
of the whole layer (its width in meters, totalHfw), the name of the layer (layer\_name), the vertical field
width of each tile (its width in meters, tileVfw), and the global stage position of the corner of the layer
(in meters, StagePosition\_corner\_x \& StagePosition\_corner\_y)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{tiles (sites\_of\_interest\_parser.MapsXmlParser attribute)@\spxentry{tiles}\spxextra{sites\_of\_interest\_parser.MapsXmlParser attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.tiles}}\pysigline{\sphinxbfcode{\sphinxupquote{tiles}}}
Contains information about individual tiles. The keys are the combined layer name \& filename of
the tile and the values are a dictionary again. Each tile contains the information about what layer it
belongs to (layer, key to the layer dict), the path to the image as a Path variable (img\_path), its
filename, the name of the layer (layer\_name) and its relative position x \& y within that layer
(RelativeTilePosition\_x \& RelativeTilePosition\_y)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{annotations (sites\_of\_interest\_parser.MapsXmlParser attribute)@\spxentry{annotations}\spxextra{sites\_of\_interest\_parser.MapsXmlParser attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.annotations}}\pysigline{\sphinxbfcode{\sphinxupquote{annotations}}}
Contains the information about all the annotations. The keys are the names of the
annotations (MAPS enforces uniqueness), its values are a dictionary containing the StagePosition\_x \&
StagePosition\_y positions of the annotation (in m =\textgreater{} global coordinate system for the experiment)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{annotation\_tiles (sites\_of\_interest\_parser.MapsXmlParser attribute)@\spxentry{annotation\_tiles}\spxextra{sites\_of\_interest\_parser.MapsXmlParser attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.annotation_tiles}}\pysigline{\sphinxbfcode{\sphinxupquote{annotation\_tiles}}}
Contains the relevant output of the XML parsing. The keys are the names of the
annotation. The values are the key to the corresponding layer in the layer dict (layer), the path to the
image as a Path variable (img\_path), its filename, the name of the layer (layer\_name) and the relative
position x \& y of the tile within that layer (RelativeTilePosition\_x \& RelativeTilePosition\_y), the
absolute stage position of the annotation (Annotation\_StagePosition\_x and Annotation\_StagePosition\_y), the
position of the annotation within the tile image (in pixels, Annotation\_tile\_img\_position\_x \&
Annotation\_tile\_img\_position\_y), a list of the surrounding tile names (surrounding\_tile\_names) and a list of
booleans of whether each of the surrounding tiles exist, including the tile itself (surrounding\_tile\_exists)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{stitch\_radius (sites\_of\_interest\_parser.MapsXmlParser attribute)@\spxentry{stitch\_radius}\spxextra{sites\_of\_interest\_parser.MapsXmlParser attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.stitch_radius}}\pysigline{\sphinxbfcode{\sphinxupquote{stitch\_radius}}}
The number of images in each direction from the tile containing the annotation should be
stitched.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{pixel\_size (sites\_of\_interest\_parser.MapsXmlParser attribute)@\spxentry{pixel\_size}\spxextra{sites\_of\_interest\_parser.MapsXmlParser attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.pixel_size}}\pysigline{\sphinxbfcode{\sphinxupquote{pixel\_size}}}
The pixel size of the acquisition in the name\_of\_highmag\_layer {[}in meters{]}
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
float

\end{description}\end{quote}

\end{fulllineitems}

\index{img\_height (sites\_of\_interest\_parser.MapsXmlParser attribute)@\spxentry{img\_height}\spxextra{sites\_of\_interest\_parser.MapsXmlParser attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.img_height}}\pysigline{\sphinxbfcode{\sphinxupquote{img\_height}}}
The height of the highmag image in pixels
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{img\_width (sites\_of\_interest\_parser.MapsXmlParser attribute)@\spxentry{img\_width}\spxextra{sites\_of\_interest\_parser.MapsXmlParser attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.img_width}}\pysigline{\sphinxbfcode{\sphinxupquote{img\_width}}}
The width of the highmag image in pixels
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate\_absolute\_tile\_coordinates() (sites\_of\_interest\_parser.MapsXmlParser method)@\spxentry{calculate\_absolute\_tile\_coordinates()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.calculate_absolute_tile_coordinates}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate\_absolute\_tile\_coordinates}}}{}{}
Calculate the absolute stage positions of all tiles based on their relative positions

Calculate the absolute stage position of the center of each tile based on the relative tile positions, the
rotation of the layer and the absolute stage position of the center of the layer. The resulting position is
saved to the \_tile\_center\_stage\_positions and the corresponding tile name to the \_tile\_names list.

\end{fulllineitems}

\index{convert\_img\_path\_to\_local\_path() (sites\_of\_interest\_parser.MapsXmlParser method)@\spxentry{convert\_img\_path\_to\_local\_path()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.convert_img_path_to_local_path}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{convert\_img\_path\_to\_local\_path}}}{\emph{img\_path}}{}
Converts a local path of the microscope computer to a path of the image in the project folder

MAPS saves the image paths of the local storage of the image files. In our setup, this path starts with
‘D:ProjectName’, even though the files aren’t actually on the D drive anymore but were copied to a share, into
the project\_folder\_path. This function strips ‘D:ProjectName’ away from the path and returns a Path object for
the location of the images on the share.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{img\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Original path to the images on the microscope computer, starting with ‘D:ProjectName’

\item[{Returns}] \leavevmode
Path object of the corrected path on the share

\item[{Return type}] \leavevmode
path

\end{description}\end{quote}

\end{fulllineitems}

\index{convert\_windows\_pathstring\_to\_path\_object() (sites\_of\_interest\_parser.MapsXmlParser static method)@\spxentry{convert\_windows\_pathstring\_to\_path\_object()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.convert_windows_pathstring_to_path_object}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{convert\_windows\_pathstring\_to\_path\_object}}}{\emph{string\_path}}{}
Converts a windows path string to a path object

Some paths are provided in the XML file and the metadata as Windows paths. This function creates pathlib Path
objects out of them.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{string\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} String of a Windows path containing double backslashes

\item[{Returns}] \leavevmode
Path object of the string\_path

\item[{Return type}] \leavevmode
path

\end{description}\end{quote}

\end{fulllineitems}

\index{create\_logger() (sites\_of\_interest\_parser.MapsXmlParser static method)@\spxentry{create\_logger()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.create_logger}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{create\_logger}}}{\emph{log\_file\_path}, \emph{multiprocessing\_logger: bool = False}}{}
Returns a logger and creates it if it doesn’t yet exist

Gets the correct logger for normal or multiprocessing. If it already exists, just returns this logger. If it
doesn’t exist yet, sets it up correctly.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{log\_file\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to the log file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{multiprocessing\_logger}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether a multiprocessing logger is needed. Defaults to False.

\end{itemize}

\item[{Returns}] \leavevmode
Logger object that has the correct handlers

\item[{Return type}] \leavevmode
logger

\end{description}\end{quote}

\end{fulllineitems}

\index{determine\_surrounding\_tiles() (sites\_of\_interest\_parser.MapsXmlParser method)@\spxentry{determine\_surrounding\_tiles()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.determine_surrounding_tiles}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{determine\_surrounding\_tiles}}}{}{}
Checks whether each annotation tile has surrounding tiles to be stitched with it

For each annotation tile, it checks whether the surrounding tiles in a given stitch\_radius exist. It saves a
boolean list of their existence (including its own existence) to surrounding\_tile\_exists and the a list of names
of the surrounding filenames to surrounding\_tile\_names of the annotation\_tiles dictionary

\end{fulllineitems}

\index{extract\_layers\_and\_annotations() (sites\_of\_interest\_parser.MapsXmlParser method)@\spxentry{extract\_layers\_and\_annotations()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.extract_layers_and_annotations}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extract\_layers\_and\_annotations}}}{\emph{check\_for\_annotations: bool = True}}{}
Extract the information about all the layers in the high magnification acquisition layers and the annotations

Go through the XML file and submit all LayerGroups for processing. The LayerGroups contain both the Layer with
the \_name\_of\_highmag\_layer (=\textgreater{} the actual images) as well as the Annotation Layers containing the annotations.
At the end of processing, check whether the self.layers and the self.annotations dictionaries were filled. If
one of them was not filled, the parser could not find the highmag images or the annotations and raises an
exception.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{check\_for\_annotations}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether the parsing should check for the existence of annotations and throw an
error if none are found. Defaults to True, thus checking for annotations.

\end{description}\end{quote}

\end{fulllineitems}

\index{find\_annotation\_tile() (sites\_of\_interest\_parser.MapsXmlParser method)@\spxentry{find\_annotation\_tile()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.find_annotation_tile}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{find\_annotation\_tile}}}{}{}
Find the image tile in which each annotation is

Based on the absolute stage position of the annotations and the calculated stage positions of the center of the
tiles, this function calculates the tiles within which all annotation are and saves this information to the
annotation\_tiles dictionary. The keys are the names of the annotation. The values are the key to the
corresponding layer in the layer dict (layer), the path to the image as a Path variable (img\_path), its
filename, the name of the layer (layer\_name) and the relative position x \& y of the tile within that layer
(RelativeTilePosition\_x \& RelativeTilePosition\_y), the absolute stage position of the annotation
(Annotation\_StagePosition\_x and Annotation\_StagePosition\_y), the position of the annotation within the tile
image (in pixels, Annotation\_tile\_img\_position\_x \& Annotation\_tile\_img\_position\_y).
The surrounding\_tile\_names and surrounding\_tile\_exists are added in determine\_surrounding\_tiles

\end{fulllineitems}

\index{get\_relative\_tile\_locations() (sites\_of\_interest\_parser.MapsXmlParser method)@\spxentry{get\_relative\_tile\_locations()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.get_relative_tile_locations}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_relative\_tile\_locations}}}{}{}
Read in all the metadata files for the different layers to get the relative tile positions

Each layer has its own metadata XML file that contains the relative positions of all the tiles in the layer.
This function goes through all of them, extracts the information and saves it to the tiles dictionary.
The keys are the combined layer name \& filename of the tile and the values are a dictionary again. Each tile
contains the information about what layer it belongs to (layer, key to the layer dict), the path to the image as
a Path variable (img\_path), its filename, the name of the layer (layer\_name) and its relative position x \& y
within that layer (RelativeTilePosition\_x \& RelativeTilePosition\_y)

\end{fulllineitems}

\index{load\_annotations\_from\_csv() (sites\_of\_interest\_parser.MapsXmlParser static method)@\spxentry{load\_annotations\_from\_csv()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.load_annotations_from_csv}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{load\_annotations\_from\_csv}}}{\emph{base\_header}, \emph{csv\_path}}{}
Load the annotations saved by sites\_of\_interest\_parser.save\_annotation\_tiles\_to\_csv

Recreates a dictionary for all the contents except the columns of the base\_header
Parses the string of a list for surrounding\_tile\_exists \& surrounding\_tile\_names back to a list
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{base\_header}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of column headers that will be ignored when loading the data

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{csv\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{Path}}) \textendash{} pathlib Path to the csv file that will be created. Must end in .csv

\end{itemize}

\item[{Returns}] \leavevmode
annotation\_tiles

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_xml() (sites\_of\_interest\_parser.MapsXmlParser static method)@\spxentry{load\_xml()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.load_xml}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{load\_xml}}}{\emph{xml\_file\_path}}{}
Loads and returns the MAPS XML File
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{xml\_file\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{Path}}) \textendash{} Path to the XML file as a pathlib path

\item[{Returns}] \leavevmode
The root of the XML file parsed with xml.etree.ElementTree

\item[{Return type}] \leavevmode
root

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_classifier\_output() (sites\_of\_interest\_parser.MapsXmlParser method)@\spxentry{parse\_classifier\_output()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.parse_classifier_output}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parse\_classifier\_output}}}{\emph{file\_path}, \emph{annotation\_shift: int = 128}}{}
Parses the output of the classifier and returns the annotation\_tiles

Goes through the csv file produced by the classifier, parses the corresponding MAPS XML File and builds the
necessary MapsXmlParser dictionaries so that they can be saved to csv afterwards. Excpects the following
structure in the classifier csv:
Dictionary with TileSets as keys and a dictionary as value. The value dictionary contains dictionaries for each
tile with annotations. The name of the tile is the key and the top left corner of the annotations are the
values, saved as a list of tuples (x,y)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{file\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to the classifier output csv

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{annotation\_shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} How much the center of the annotation is shifted from the top left corner. Defaults
to 128 (for 256x256 images from the classifier)

\end{itemize}

\item[{Returns}] \leavevmode
Dictionary of all annotation tiles

\item[{Return type}] \leavevmode
self.annotation\_tiles

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_xml() (sites\_of\_interest\_parser.MapsXmlParser method)@\spxentry{parse\_xml()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.parse_xml}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parse\_xml}}}{}{}
Run function for the class

parse\_xml calls all the necessary functions of the class in the correct order to parse the XML file. Call this
function after initializing a class object, then access the results via the annotation\_tiles variable that
contains the relevant output of the XML parsing
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
annotation\_tiles

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_annotation\_tiles\_to\_csv() (sites\_of\_interest\_parser.MapsXmlParser static method)@\spxentry{save\_annotation\_tiles\_to\_csv()}\spxextra{sites\_of\_interest\_parser.MapsXmlParser static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.MapsXmlParser.save_annotation_tiles_to_csv}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{save\_annotation\_tiles\_to\_csv}}}{\emph{annotation\_tiles}, \emph{base\_header}, \emph{csv\_path}, \emph{batch\_size=0}}{}
Saves the information about all annotations to a csv file

Goes through the annotation\_tiles dictionary and saves it to a csv file. Overwrites any existing file in
the same location. Can write everything into one csv file (default) or into multiple batches of a given size
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{annotation\_tiles}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} annotation tiles dictionary with a structure like self.annotation\_tiles

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{base\_header}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of strings that will be headers but will not contain any content

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{csv\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{Path}}) \textendash{} pathlib Path to the csv file that will be created. Must end in .csv

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{batch\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The size of each batch. Defaults to 0. If it’s 0, everything is saved into one csv file.
Otherwise, the dataframe is divided into batches of batch\_size and saved to separate csv files

\end{itemize}

\item[{Returns}] \leavevmode
list of all the paths to the saved csv files

\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{XmlParsingFailed@\spxentry{XmlParsingFailed}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:sites_of_interest_parser.XmlParsingFailed}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{exception }}\sphinxcode{\sphinxupquote{sites\_of\_interest\_parser.}}\sphinxbfcode{\sphinxupquote{XmlParsingFailed}}}{\emph{message}}{}
\end{fulllineitems}

\phantomsection\label{\detokenize{index:module-stitch_MAPS_annotations}}\index{stitch\_MAPS\_annotations (module)@\spxentry{stitch\_MAPS\_annotations}\spxextra{module}}\index{Stitcher (class in stitch\_MAPS\_annotations)@\spxentry{Stitcher}\spxextra{class in stitch\_MAPS\_annotations}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{stitch\_MAPS\_annotations.}}\sphinxbfcode{\sphinxupquote{Stitcher}}}{\emph{base\_path: str}, \emph{project\_name: str}, \emph{csv\_folder: str = 'annotation\_csv'}, \emph{output\_folder: str = 'stitchedForks'}, \emph{stitch\_radius: int = 1}}{}
Stitches Talos images based on csv files containing the necessary information

This class handles the stitching of Talos images based on a csv file like the one created by the MapsXmlParser.
It creates the necessary folders, calls MapsXmlParser for the parsing and saving of the necessary metadata and then
manages the stitching of all annotations. Current implementation of stitching is hard-coded to stitch\_radius = 1,
the size of the Talos images and an overlap of 10\% in its stitching parameters in the stitch\_annotated\_tiles
function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{base\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path (as a string) to the directory containing the project\_name folder.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{project\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the directory containing the MAPSProject.xml file and the LayersData
folder of the MAPS project. Will be used as the location for the output folders. Must be in base\_path folder

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{csv\_folder}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the folders where the csv files are saved to

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_folder}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the folder where the stitched forks are saved to

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stitch\_radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of images in each direction from the tile containing the annotation should be
stitched.

\end{itemize}

\end{description}\end{quote}
\index{stitch\_radius (stitch\_MAPS\_annotations.Stitcher attribute)@\spxentry{stitch\_radius}\spxextra{stitch\_MAPS\_annotations.Stitcher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.stitch_radius}}\pysigline{\sphinxbfcode{\sphinxupquote{stitch\_radius}}}
The number of images in each direction from the tile containing the annotation should be
stitched.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
int

\end{description}\end{quote}

\end{fulllineitems}

\index{project\_name (stitch\_MAPS\_annotations.Stitcher attribute)@\spxentry{project\_name}\spxextra{stitch\_MAPS\_annotations.Stitcher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.project_name}}\pysigline{\sphinxbfcode{\sphinxupquote{project\_name}}}
Name of the current project being processed
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
str

\end{description}\end{quote}

\end{fulllineitems}

\index{project\_folder\_path (stitch\_MAPS\_annotations.Stitcher attribute)@\spxentry{project\_folder\_path}\spxextra{stitch\_MAPS\_annotations.Stitcher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.project_folder_path}}\pysigline{\sphinxbfcode{\sphinxupquote{project\_folder\_path}}}
Full path to the project folder, containing the MAPSProject.xml file and the
LayersData folder
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
Path

\end{description}\end{quote}

\end{fulllineitems}

\index{output\_path (stitch\_MAPS\_annotations.Stitcher attribute)@\spxentry{output\_path}\spxextra{stitch\_MAPS\_annotations.Stitcher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.output_path}}\pysigline{\sphinxbfcode{\sphinxupquote{output\_path}}}
Full path to the output folder where the stitched images are stored
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
Path

\end{description}\end{quote}

\end{fulllineitems}

\index{csv\_base\_path (stitch\_MAPS\_annotations.Stitcher attribute)@\spxentry{csv\_base\_path}\spxextra{stitch\_MAPS\_annotations.Stitcher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.csv_base_path}}\pysigline{\sphinxbfcode{\sphinxupquote{csv\_base\_path}}}
Full path to the folder where the csv files with all annotation metadata are stored
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
Path

\end{description}\end{quote}

\end{fulllineitems}

\index{base\_header (stitch\_MAPS\_annotations.Stitcher attribute)@\spxentry{base\_header}\spxextra{stitch\_MAPS\_annotations.Stitcher attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.base_header}}\pysigline{\sphinxbfcode{\sphinxupquote{base\_header}}}
List of all the column headers that should be added to the csv file (for classification of
annotations and for measurements made on them)
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{combine\_csvs() (stitch\_MAPS\_annotations.Stitcher method)@\spxentry{combine\_csvs()}\spxextra{stitch\_MAPS\_annotations.Stitcher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.combine_csvs}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{combine\_csvs}}}{\emph{delete\_batches: bool = False}, \emph{to\_excel: bool = True}}{}
Combines batch csv output files into the final csv file and optionally an excel file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{delete\_batches}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether the batch csv files should be deleted after stitching them to the combined
csv file. Defaults to False (not deleting the batch csv files)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{to\_excel}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether the csv file should also be saved as an excel file. Defaults to True (creating the
Excel file)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{local\_contrast\_enhancement() (stitch\_MAPS\_annotations.Stitcher static method)@\spxentry{local\_contrast\_enhancement()}\spxextra{stitch\_MAPS\_annotations.Stitcher static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.local_contrast_enhancement}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{local\_contrast\_enhancement}}}{\emph{img\_path}, \emph{output\_path}, \emph{logger=None}, \emph{save\_img: bool = False}, \emph{eight\_bit: bool = True}, \emph{use\_norm\_local\_contrast: bool = False}, \emph{use\_CLAHE: bool = False}, \emph{return\_java\_img: bool = False}, \emph{return\_numpy\_img: bool = False}, \emph{**kwargs}}{}
Loads an image and performs local contrast enhancement

Loads the specified image, performs either NormalizeLocalContrast (default), CLAHE or no local contrast
enhancement (in that order, thus performs NormalizeLocalContrast if both it and CLAHE are True).
Optionally converts the image to 8bit and saves it. The parameters for NormalizeLocalContrast and
CLAHE have default values that can be overwritten using the {\color{red}\bfseries{}**}kwargs by providing an argument with the specific
name of the parameter to be changed
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{img\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{Path}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Full path to the image to be processed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{output\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{Path}}\sphinxstyleliteralemphasis{\sphinxupquote{ or }}\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Full path to where the output image should be saved (if save\_img is True)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{logger}} (\sphinxstyleliteralemphasis{\sphinxupquote{Logging}}) \textendash{} Logging object that is configured for the logging either in multiprocessing or normal
processing. Defaults to None, thus loading the logger

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{save\_img}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether the processed image should be saved. Defaults to False (not saving the image)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eight\_bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether the image should be converted to 8 bit . Defaults to True (converting to 8 bit)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{use\_norm\_local\_contrast}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether NormalizeLocalContrast Fiji Plugin should be run on the image.
Defaults to False (not running NormalizeLocalContrast on the image)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{use\_CLAHE}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether CLAHE Fiji Plugin should be run on the image. Defaults to False (not running
CLAHE on the image)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_java\_img}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether the function should return the java image. Defaults to False (not returning
the image)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_numpy\_img}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether the function should return a numpy version of the image. Defaults to False
(not returning the image)

\end{itemize}

\item[{Returns}] \leavevmode
The processed image as an ImageJ1 ImagePlus image (if return\_image is True)

\item[{Return type}] \leavevmode
ImagePlus

\end{description}\end{quote}

\end{fulllineitems}

\index{manage\_batches() (stitch\_MAPS\_annotations.Stitcher method)@\spxentry{manage\_batches()}\spxextra{stitch\_MAPS\_annotations.Stitcher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.manage_batches}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{manage\_batches}}}{\emph{stitch\_threshold: int = 1000}, \emph{eight\_bit: bool = True}, \emph{show\_arrow: bool = True}, \emph{max\_processes: int = 4}, \emph{enhance\_contrast: bool = True}}{}
Manages the parallelization of the stitching of batches

As multiprocessing can make some issues, if max\_processes is set to 1, it does not use multiprocessing calls.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stitch\_threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Threshold to judge stitching quality by. If images would be moved more than this
threshold, the stitching is not performed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eight\_bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether the stitched image should be saved as an 8bit image. Defaults to True, thus saving
images as 8bit

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_arrow}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether an arrow should be added to the image overlay that points to the annotation in
the stitched image. Defaults to True, thus adding an arrow to the overlay

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_processes}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of parallel processes that should be used to process the batches.
Be careful, each batch needs a lot of memory

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{enhance\_contrast}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether contrast enhancement should be performed on the images before stitching.
Defaults to True (thus enhancing contrast in the images)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_create\_classifier\_csv\_batches() (stitch\_MAPS\_annotations.Stitcher method)@\spxentry{parse\_create\_classifier\_csv\_batches()}\spxextra{stitch\_MAPS\_annotations.Stitcher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.parse_create_classifier_csv_batches}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parse\_create\_classifier\_csv\_batches}}}{\emph{batch\_size: int}, \emph{classifier\_csv\_path: str}, \emph{highmag\_layer: str = 'highmag'}}{}
Creates the batch csv files of annotation\_tiles based on classifier output

Calls the MapsXmlParser to parse the XML file of the acquisition and save the annotation\_tiles as a csv in
batches
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{batch\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Batch size of the csv files

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{classifier\_csv\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to the classifier output csv file

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{highmag\_layer}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the image layer in MAPS for which tiles containing annotations should
be found. Defaults to ‘highmag’

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{First value: The annotation\_tiles dictionary. Second value: A list of the filenames of the csv files}] \leavevmode
that were created

\end{description}


\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{parse\_create\_csv\_batches() (stitch\_MAPS\_annotations.Stitcher method)@\spxentry{parse\_create\_csv\_batches()}\spxextra{stitch\_MAPS\_annotations.Stitcher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.parse_create_csv_batches}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{parse\_create\_csv\_batches}}}{\emph{batch\_size: int}, \emph{highmag\_layer: str = 'highmag'}}{}
Creates the batch csv files of annotation\_tiles

Calls the MapsXmlParser to parse the XML file of the acquisition and save the annotation\_tiles as a csv in
batches
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{batch\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Batch size of the csv files

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{highmag\_layer}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Name of the image layer in MAPS for which tiles containing annotations should
be found. Defaults to ‘highmag’

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{First value: The annotation\_tiles dictionary. Second value: A list of the filenames of the csv files}] \leavevmode
that were created

\end{description}


\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{process\_stitching\_params() (stitch\_MAPS\_annotations.Stitcher static method)@\spxentry{process\_stitching\_params()}\spxextra{stitch\_MAPS\_annotations.Stitcher static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.process_stitching_params}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{process\_stitching\_params}}}{\emph{stitch\_params}, \emph{annotation\_coordinates}, \emph{stitch\_threshold}, \emph{original\_positions}, \emph{center\_index: int}, \emph{logger}}{}
Calculates the position of the annotation in the stitched image and decides if stitching worked well

Based on the stitch\_threshold, this function decides whether the stitching has worked well. If any image was
moved by more than the threshold, it returns False.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stitch\_params}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} Array of the stitching parameters calculated by imageJ stitching

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{annotation\_coordinates}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}) \textendash{} Array of the coordinates of the annotation in the image before stitching

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stitch\_threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Threshold to decide whether stitching should be performed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{original\_positions}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.Array}}) \textendash{} Array of the initial positions of the images before stitching, used to
calculate the shift by stitching

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{center\_index}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Index of which tile in the stitched image was the original center. Used to calculate
the position of the annotation in the stitched image

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{logger}} (\sphinxstyleliteralemphasis{\sphinxupquote{Logging}}) \textendash{} Logging object that is configured for the logging either in multiprocessing or normal
processing

\end{itemize}

\item[{Returns}] \leavevmode
\begin{description}
\item[{First value is a bool that informs whether the stitching should be done. Second value is an array with}] \leavevmode
the coordinates of the annotations in the stitched image

\end{description}


\item[{Return type}] \leavevmode
list

\end{description}\end{quote}

\end{fulllineitems}

\index{stitch\_annotated\_tiles() (stitch\_MAPS\_annotations.Stitcher method)@\spxentry{stitch\_annotated\_tiles()}\spxextra{stitch\_MAPS\_annotations.Stitcher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.stitch_annotated_tiles}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stitch\_annotated\_tiles}}}{\emph{annotation\_tiles: dict}, \emph{logger}, \emph{stitch\_threshold: int = 1000}, \emph{eight\_bit: bool = True}, \emph{show\_arrow: bool = True}, \emph{enhance\_contrast: bool = True}}{}
Stitches 3x3 images for all annotations in annotation\_tiles

Goes through all annotations in annotation\_tiles dict, load the center file and the existing surrounding files.
Sets up the stitching configuration according to the neighboring tiles and calculates the stitching parameters.
If the calculated stitching moves all images by less than the threshold in any direction, it performs the
stitching. Otherwise, a log message is made and the center image is copied to the results folder.
Finally, it sets the pixel size and converts the stitched image to 8bit before saving it to disk. Everything is
performed using pyimagej api to use imageJ Java APIs.
Can deal with 3x3, 3x2, 2x3 and 2x2 squares with 10\% overlap.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{annotation\_tiles}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} annotation\_tiles dictionary, e.g. from MapsXmlParser. See MapsXmlParser for content
details. Needs to contain img\_path, pixel\_size, Annotation\_tile\_img\_position\_x,
Annotation\_tile\_img\_position\_y, surrounding\_tile\_names \& surrounding\_tile\_exists for this function
to work

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{logger}} (\sphinxstyleliteralemphasis{\sphinxupquote{Logging}}) \textendash{} Logging object that is configured for the logging either in multiprocessing or normal
processing

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stitch\_threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Threshold to judge stitching quality by. If images would be moved more than this
threshold, the stitching is not performed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eight\_bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether the stitched image should be saved as an 8bit image. Defaults to True, thus saving
images as 8bit

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_arrow}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether an arrow should be added to the image overlay that points to the annotation in
the stitched image. Defaults to True, thus adding an arrow to the overlay

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{enhance\_contrast}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether contrast enhancement should be performed on the images before stitching.
Defaults to True (thus enhancing contrast in the images)

\end{itemize}

\item[{Returns}] \leavevmode
annotation\_tiles, now includes information about the position of the annotation in the stitched image

\item[{Return type}] \leavevmode
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{stitch\_batch() (stitch\_MAPS\_annotations.Stitcher method)@\spxentry{stitch\_batch()}\spxextra{stitch\_MAPS\_annotations.Stitcher method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:stitch_MAPS_annotations.Stitcher.stitch_batch}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stitch\_batch}}}{\emph{annotation\_csv\_path}, \emph{stitch\_threshold: int = 1000}, \emph{eight\_bit: bool = True}, \emph{show\_arrow: bool = True}, \emph{enhance\_contrast: bool = True}, \emph{multiprocessing\_logger: bool = False}}{}
Submits the stitching of a batch, the writing of an updated csv file and the deletion of the old csv file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{annotation\_csv\_path}} (\sphinxstyleliteralemphasis{\sphinxupquote{Path}}) \textendash{} The path to the folder containing the annotation\_tiles csvs.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{stitch\_threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Threshold to judge stitching quality by. If images would be moved more than this
threshold, the stitching is not performed

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eight\_bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether the stitched image should be saved as an 8bit image. Defaults to True, thus saving
images as 8bit

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{show\_arrow}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether an arrow should be added to the image overlay that points to the annotation in
the stitched image. Defaults to True, thus adding an arrow to the overlay

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{enhance\_contrast}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether contrast enhancement should be performed on the images before stitching.
Defaults to True (thus enhancing contrast in the images)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{multiprocessing\_logger}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether a multiprocessing logger or a normal logger should be used. Defaults
to False, thus using a normal logger

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{s}
\item\relax\sphinxstyleindexentry{sites\_of\_interest\_parser}\sphinxstyleindexpageref{index:\detokenize{module-sites_of_interest_parser}}
\item\relax\sphinxstyleindexentry{stitch\_MAPS\_annotations}\sphinxstyleindexpageref{index:\detokenize{module-stitch_MAPS_annotations}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}